<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Vocabulary Review</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;500;600;700&family=Noto+Serif+SC:wght@500;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #FF8C7C;
            --primary-light:#FFAFA3;
            --primary-dark: #FF6F61;
            --neutral-50: #f8fafc;
            --neutral-100: #f1f5f9;
            --neutral-200: #e2e8f0;
            --neutral-300: #cbd5e1;
            --neutral-400: #9ca3af; /* Added for hover border */
            --neutral-600: #475569;
            --neutral-700: #334155;
            --neutral-800: #1e293b;
            --neutral-900: #0f172a;
            --success: #10b981;
            --success-light: #d1fae5;
            --warning: #f59e0b;
            --warning-light: #fef3c7;
            --card-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --transition-normal: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-bounce: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

	     /* Add these styles for the search functionality */
        .search-container {
            margin-bottom: 1.5rem;
            width: 100%;
        }
        
        .search-input-group {
            display: flex;
            position: relative;
            margin-bottom: 0.5rem;
        }
        
        .search-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem 0 0 0.5rem;
            border: 1px solid var(--neutral-300);
            font-size: 0.875rem;
            color: var(--neutral-800);
        }
        
        .search-input:focus {
            outline: 2px solid var(--primary-light);
            border-color: var(--primary);
        }
        
        .search-btn {
            background-color: var(--primary);
            color: white;
            border: 1px solid var(--primary);
            border-radius: 0 0.5rem 0.5rem 0;
            padding: 0.75rem 1rem;
            font-family: 'Noto Sans', sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .search-btn:hover {
            background-color: var(--primary-dark);
        }
        
        .search-results {
            display: none;
            background: white;
            border-radius: 0.5rem;
            border: 1px solid var(--neutral-300);
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .search-result-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--neutral-200);
            cursor: pointer;
            transition: var(--transition-normal);
            display: flex;
            align-items: center;
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover {
            background-color: var(--neutral-100);
        }
        
        .search-result-character {
            font-family: 'Noto Serif SC', serif;
            font-size: 1.5rem;
            margin-right: 0.75rem;
            font-weight: 700;
        }
        
        .search-result-details {
            flex: 1;
        }
        
        .search-result-pinyin {
            font-weight: 600;
            color: var(--primary-dark);
            margin-bottom: 0.25rem;
        }
        
        .search-result-meaning {
            font-size: 0.8rem;
            color: var(--neutral-700);
        }
        
        .search-result-meta {
            font-size: 0.7rem;
            color: var(--neutral-600);
            margin-top: 0.25rem;
        }
        
        .search-clear {
    position: absolute;
    right: 5rem; /* Updated position */
    top: 50%;
    transform: translateY(-50%);
    color: var(--neutral-600);
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 1.25rem;
    line-height: 1;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: none;
    font-weight: 600;
    text-align: center;
    padding: 0;
}
        
        .search-clear:hover {
            background-color: var(--neutral-200);
        }
        
        .search-toggle {
            background-color: white;
            color: var(--neutral-700);
            border: 1px solid var(--neutral-300);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-family: 'Noto Sans', sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            width: 100%;
        }
        
        .search-toggle:hover {
            background-color: var(--neutral-100);
            border-color: var(--neutral-400);
        }
        
        .search-toggle svg {
            margin-right: 0.5rem;
        }
        
        /* Mobile optimizations */
        @media (max-width: 480px) {
            .search-btn {
                padding: 0.75rem 0.5rem;
            }
        }
        body {
            font-family: 'Noto Sans', sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: var(--neutral-800);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .app-container {
            width: 100%;
            max-width: 500px;
            overflow: hidden;
        }
        .app-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .app-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--neutral-800);
            margin-bottom: 0.5rem;
        }
        .app-subtitle {
            font-size: 0.875rem;
            color: var(--neutral-600);
        }
        .flashcard-scene {
            perspective: 1000px;
            height: 300px;
            margin-bottom: 1.5rem;
        }
        .flashcard {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: var(--transition-bounce);
            border-radius: 1rem;
            box-shadow: var(--card-shadow);
        }
        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }
        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 1rem;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }
        .flashcard-front {
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border: 1px solid var(--neutral-200);
        }
        .flashcard-back {
            background: linear-gradient(145deg, #ffffff, #f8fafc);
           
            transform: rotateY(180deg);
            text-align: center;
        }
        .character-display {
            font-family: 'Noto Serif SC', serif;
            font-size: 7rem;
            font-weight: 700;
            line-height: 1;
            color: var(--neutral-900);
            margin-bottom: 1.5rem;
            transition: var(--transition-normal);
        }
        .character-note {
            font-size: 0.75rem;
            color: var(--neutral-600);
            position: absolute;
            bottom: 1rem;
            left: 0;
            right: 0;
            text-align: center;
        }
        .back-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        .pinyin-display {
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--primary-dark);
            margin-bottom: 1rem;
        }
        .meaning-display {
            font-size: 1.25rem;
            color: var(--neutral-700);
            margin-bottom: 1.5rem;
            line-height: 1.4;
        }
        .word-details {
            background-color: rgba(255, 255, 255, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            color: var(--neutral-600);
        }
        .controls {
            display: grid; /* Keep grid for overall structure */
            /* grid-template-columns: repeat(2, 1fr); No longer needed like this*/
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .controls-row {
            /* grid-column: span 2; Removed as controls is no longer 2 cols */
            display: flex;
            gap: 1rem;
            justify-content: center; /* <<< Added this line to center the buttons */
        }
        .btn {
            background: white;
            color: var(--neutral-700);
            border: 1px solid var(--neutral-300);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-family: 'Noto Sans', sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        .btn:hover {
            background-color: var(--neutral-100);
            border-color: var(--neutral-400); /* Use defined neutral-400 */
        }
        .btn:active {
            transform: translateY(1px);
        }
        .btn-nav {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
            padding: 0.5rem;
            width: 40px; /* Fixed width */
            height: 40px; /* Fixed height */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .btn-nav:hover {
            background-color: var(--primary-dark);
            border-color: var(--primary-dark);
        }
        .btn-primary {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
            width: 40%; /* Make reset button full width */
            margin-top: 1rem; /* Add space above reset button */
           margin-left: auto;  /* Add these two lines */
    margin-right: auto; /* to center the button */
    display: block;     /* Make it a block element */

        }
        .btn-primary:hover {
            background-color: var(--primary-dark);
            border-color: var(--primary);
        }
        .btn-mark {
            transition: var(--transition-normal);
            min-width: 100px; /* Give mark button a min width */
        }
        .btn-mark.marked {
            background-color: var(--warning-light);
            color: var(--warning);
            border-color: var(--warning);
        }
        .btn svg { /* Ensure SVGs scale properly */
           pointer-events: none; /* Prevent SVG intercepting clicks */
        }
        .filters {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--neutral-200);
        }
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        .filter-group {
            /* Removed margin-bottom: 1rem; - handled by gap */
        }
        .filter-label {
            display: block;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--neutral-700);
            margin-bottom: 0.375rem;
        }
        select {
            width: 100%;
            padding: 0.75rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.375rem;
            border: 1px solid var(--neutral-300);
            background-color: white;
            color: var(--neutral-800);
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            cursor: pointer; /* Add cursor */
        }
        select:focus {
            outline: 2px solid var(--primary-light);
            border-color: var(--primary);
        }
        select[multiple] {
            height: 80px; /* Adjusted height */
            background-image: none;
            padding-right: 0.75rem;
            overflow-y: auto; /* Add scroll for multiple */
        }
        .progress-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 1rem;
            font-size: 0.75rem;
            color: var(--neutral-600);
        }
        .progress-bar {
            height: 4px;
            background-color: var(--neutral-200);
            border-radius: 9999px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        .progress-value {
            height: 100%;
            background-color: var(--primary);
            border-radius: 9999px;
            transition: width 0.3s ease;
        }
        .message-area {
            min-height: 1.25rem;
            text-align: center;
            font-size: 0.75rem;
            color: var(--primary-dark);
            margin-top: 0.75rem;
        }
        .marked-indicator {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background-color: var(--warning-light);
            color: var(--warning);
            font-size: 0.75rem;
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            border: 1px solid var(--warning);
            display: none; /* Initially hidden, controlled by JS */
        }
        /* Mobile optimizations */
        @media (max-width: 480px) {
            .filters-grid {
                grid-template-columns: 1fr;
            }
            .character-display {
                font-size: 5rem;
            }
            .flashcard-scene {
                height: 250px;
            }
            .btn {
                padding: 0.6rem 0.8rem; /* Slightly smaller padding */
                font-size: 0.8rem;
            }
            .btn-nav {
                 width: 36px;
                 height: 36px;
            }
            .btn-mark {
                 min-width: 80px;
            }
            .controls-row {
                gap: 0.5rem; /* Reduce gap on mobile */
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-header">
            <h1 class="app-title">Chinese Vocabulary Flashcards</h1>
   
        </div>
 <!-- Add search toggle button -->
        <button id="searchToggle" class="search-toggle">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.3-4.3"></path>
            </svg>
            Search Vocabulary
        </button>
        
        <!-- Add search container -->
        <div class="search-container" id="searchContainer" style="display: none;">
            <div class="search-input-group">
                <input type="text" id="searchInput" class="search-input" placeholder="Search by character, pinyin, or meaning...">
                <button id="searchClear" class="search-clear" aria-label="Clear search">x</button>
                <button id="searchButton" class="search-btn">Search</button>
            </div>
            <div id="searchResults" class="search-results"></div>
        </div>
        <div class="flashcard-scene">
            <div class="flashcard" id="flashcard">
                <div class="flashcard-face flashcard-front">
                    <div class="character-display" id="characterDisplay">爱</div>
                    <div id="markedIndicator" class="marked-indicator"></div>
                    <p class="character-note">Tap to reveal details</p>
                </div>
                <div class="flashcard-face flashcard-back">
                    <div class="back-content">
                        <div class="pinyin-display" id="pinyinDisplay">ài</div>
                        <div class="meaning-display" id="meaningDisplay">to love; affection</div>
                        <div class="word-details" id="wordDetails">HSK3 · Lesson 1</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="controls-row">
                <button id="prevBtn" class="btn btn-nav" aria-label="Previous Word">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m15 18-6-6 6-6"/>
                    </svg>
                </button>
                <button id="markYBtn" class="btn btn-mark">Re-learn</button>
                <button id="shuffleBtn" class="btn" aria-label="Shuffle Words">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l6.1-8.6c.7-1.1 2-1.7 3.3-1.7H22"/>
                        <path d="m18 2 4 4-4 4"/>
                        <path d="M2 6h1.9c1.5 0 2.9.9 3.6 2.2"/>
                        <path d="M22 18h-5.9c-1.3 0-2.6-.7-3.3-1.8l-.5-.8"/>
                        <path d="m18 14 4 4-4 4"/>
                    </svg>
                </button>
                <button id="nextBtn" class="btn btn-nav" aria-label="Next Word">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m9 18 6-6-6-6"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="filters">
            <div class="filters-grid">
                <div class="filter-group">
                    <label for="levelFilter" class="filter-label">HSK Level</label>
                    <select id="levelFilter">
			<option value="HSK1-2">HSK 1-2</option>
                        <option value="HSK3">HSK 3</option>
                        <option value="HSK4">HSK 4</option>
			<option value="HSK5">HSK 5</option>
                        </select>
                </div>
                <div class="filter-group">
                    <label for="lessonFilter" class="filter-label">Lesson Filter</label>
                    <select id="lessonFilter" multiple>
                        <option value="all" selected>All Lessons</option>
                        <option value="marked_y">Only Re-learn</option>
                        </select>
                </div>
            </div>
            <button id="resetBtn" class="btn btn-primary">Reset</button>
            <div class="progress-info">
                <span id="wordCounter">Word 0 of 0</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-value" id="progressBar" style="width: 0%;"></div>
            </div>
            <div class="message-area" id="messageArea"></div>
        </div>
    </div>

    <script>
        
        // --- State Variables ---
	let currentWordIndex = 0;
	let currentWordList = [];
	let allWords = []; // Will be populated after fetching
	let markedWords = {};
	let currentFilterLevel = 'HSK3';
	let currentLessonSelection = ['all'];

        // --- DOM Elements ---
        const flashcard = document.getElementById('flashcard');
        const characterDisplay = document.getElementById('characterDisplay');
        const pinyinDisplay = document.getElementById('pinyinDisplay');
        const meaningDisplay = document.getElementById('meaningDisplay');
        const wordDetails = document.getElementById('wordDetails');
        const markedIndicator = document.getElementById('markedIndicator');
        const markYBtn = document.getElementById('markYBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const levelFilter = document.getElementById('levelFilter');
        const lessonFilter = document.getElementById('lessonFilter');
        const resetBtn = document.getElementById('resetBtn');
        const wordCounter = document.getElementById('wordCounter');
        const progressBar = document.getElementById('progressBar');
        const progressPercent = document.getElementById('progressPercent');
        const messageArea = document.getElementById('messageArea');

	// --- Google Sheet Configuration ---
	const GOOGLE_SHEET_PUBLISHED_CSV_URL = 'https://script.google.com/macros/s/AKfycbwJZLtCPX98-AorcG_L3nxHAYMkeKjaJ2PEUO8ofd1e8wWTNG7MGdkQp8-4FdL-vz5r/exec'; 

        // --- Local Storage ---
        const STORAGE_KEY = 'chineseFlashcard_markedWords_v4'; // Increment version if data structure changes

        function loadMarkedWords() {
    const stored = localStorage.getItem(STORAGE_KEY);
    markedWords = stored ? JSON.parse(stored) : {};
    // We'll apply the marking *after* fetching the words
}
  // --- Search Functionality ---
        const searchToggle = document.getElementById('searchToggle');
        const searchContainer = document.getElementById('searchContainer');
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const searchClear = document.getElementById('searchClear');
        const searchResults = document.getElementById('searchResults');
        
        // Toggle search panel
        searchToggle.addEventListener('click', () => {
            const isVisible = searchContainer.style.display !== 'none';
            searchContainer.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                searchInput.focus();
            }
        });
        
        // Clear search input
        searchClear.addEventListener('click', () => {
            searchInput.value = '';
            searchResults.style.display = 'none';
            searchClear.style.display = 'none';
        });
        
        // Show/hide clear button based on input
        searchInput.addEventListener('input', () => {
            searchClear.style.display = searchInput.value ? 'block' : 'none';
        });
        
        // Perform search when Enter key is pressed
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                searchButton.click();
            }
        });
        
        // Perform search
        searchButton.addEventListener('click', performSearch);
        
        function performSearch() {
            const query = searchInput.value.trim().toLowerCase();
            if (!query) {
                searchResults.style.display = 'none';
                return;
            }
            
            // Find matching words
            const matches = allWords.filter(word => {
                return word.character.includes(query) || 
                       word.pinyin.toLowerCase().includes(query) || 
                       word.meaning.toLowerCase().includes(query);
            });
            
            displaySearchResults(matches);
        }
        
        function displaySearchResults(matches) {
            searchResults.innerHTML = '';
            
            if (matches.length === 0) {
                searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
                searchResults.style.display = 'block';
                return;
            }
            
            matches.forEach(word => {
                const resultItem = document.createElement('div');
                resultItem.className = 'search-result-item';
                resultItem.innerHTML = `
                    <div class="search-result-character">${word.character}</div>
                    <div class="search-result-details">
                        <div class="search-result-pinyin">${word.pinyin}</div>
                        <div class="search-result-meaning">${word.meaning}</div>
                        <div class="search-result-meta">${word.level} · Lesson ${word.lesson}</div>
                    </div>
                `;
                
                // Handle click on search result
                resultItem.addEventListener('click', () => {
                    showWordByCharacter(word.character);
                    searchResults.style.display = 'none';
                });
                
                searchResults.appendChild(resultItem);
            });
            
            searchResults.style.display = 'block';
        }
        
        function showWordByCharacter(character) {
            // First try finding in the current filtered list
            let foundIndex = currentWordList.findIndex(word => word.character === character);
            
            if (foundIndex !== -1) {
                // Word is in current list, just update index
                currentWordIndex = foundIndex;
                displayWord();
                updateProgress();
                return;
            }
            
            // Word not in current filtered list, need to find in all words
            const wordData = allWords.find(word => word.character === character);
            if (!wordData) return; // Safety check
            
            // Update filters to include this word
            levelFilter.value = wordData.level;
            currentFilterLevel = wordData.level;
            
            // Update lesson filter to match the word's lesson
            populateLessonFilter();
            
            // Select specific lesson option
            for (let i = 0; i < lessonFilter.options.length; i++) {
                if (lessonFilter.options[i].value === wordData.lesson.toString()) {
                    lessonFilter.options[0].selected = false; // Deselect "All Lessons"
                    lessonFilter.options[i].selected = true;
                    break;
                }
            }
            
            // Apply the new filters
            applyFilters(false); // Don't shuffle to keep order predictable
            
            // Find the word in the newly filtered list
            foundIndex = currentWordList.findIndex(word => word.character === character);
            if (foundIndex !== -1) {
                currentWordIndex = foundIndex;
                displayWord();
                updateProgress();
            }
            
            // Show message
            showMessage(`Showing "${character}" and filtered to ${wordData.level} Lesson ${wordData.lesson}`, 3000);
        }
async function fetchWordsFromSheet() {
    showMessage('Loading words...', 0);
    try {
        // Fetch from the Apps Script Web App URL
         const response = await fetch(GOOGLE_SHEET_PUBLISHED_CSV_URL); // <-- Use the correct variable name here
        if (!response.ok) {
             // You might want to try getting text first for better error details from Apps Script
             const errorText = await response.text();
             throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
        }
        // Parse the response as JSON
        const jsonData = await response.json();

        // Check if the Apps Script returned an error object
        if (jsonData.error) {
            throw new Error(`Apps Script Error: ${jsonData.error}`);
        }

        // Assuming your Apps Script returns an array of objects
        // with keys matching your original headers (character, pinyin, etc.)
        allWords = jsonData.map(item => ({
            character: item.character || '', // Add default values in case a column is missing
            pinyin: item.pinyin || '',
            meaning: item.meaning || '',
            level: item.level || '',
            // Apps script might return numbers directly, but ensure consistency
            lesson: parseInt(item.lesson, 10) || 0,
            markedY: markedWords[item.character] === true // Apply marking
        })).filter(word => word.character); // Filter out potentially empty rows

        console.log(`Processed ${allWords.length} words from Apps Script.`);
        showMessage('');
        return true;

    } catch (error) {
        console.error('Error fetching or processing Apps Script data:', error);
        characterDisplay.textContent = '⚠️';
        meaningDisplay.textContent = 'Error loading words. Check console or Apps Script.';
        pinyinDisplay.textContent = '';
        wordDetails.textContent = '';
        showMessage('Failed to load words.', 0);
        [prevBtn, nextBtn, markYBtn, shuffleBtn, flashcard, levelFilter, lessonFilter, resetBtn].forEach(el => el.disabled = true);
        flashcard.style.cursor = 'default';
        return false;
    }
}            
        

        function saveMarkedWords() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(markedWords));
            } catch (e) {
                console.error("Failed to save marked words to local storage:", e);
                showMessage("Error saving progress.", 5000);
            }
        }

        // --- Utility Functions ---
        function shuffleArray(array) {
            // Fisher-Yates (aka Knuth) Shuffle
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function populateLessonFilter() {
            const lessonsInLevel = [...new Set(allWords
                .filter(word => word.level === currentFilterLevel)
                .map(word => word.lesson))]
                .sort((a, b) => a - b); // Sort lessons numerically

            // Clear existing lesson options (keep "All Lessons" and "Only Re-learn")
            while (lessonFilter.options.length > 2) {
                lessonFilter.remove(2);
            }

            // Add options for each lesson found in the selected HSK level
            lessonsInLevel.forEach(lesson => {
                const option = document.createElement('option');
                option.value = lesson;
                option.textContent = `Lesson ${lesson}`;
                lessonFilter.appendChild(option);
            });

            // Reset selection after populating
            resetLessonFilterSelection();
        }

        function resetLessonFilterSelection() {
             // Deselect all options first
            for (let i = 0; i < lessonFilter.options.length; i++) {
                lessonFilter.options[i].selected = false;
            }
            // Select the 'All Lessons' option
            lessonFilter.options[0].selected = true;
            currentLessonSelection = ['all']; // Update state
        }

        function getSelectedLessons() {
            const selectedOptions = Array.from(lessonFilter.selectedOptions);
            const selectedValues = selectedOptions.map(opt => opt.value);

            // If 'all' is selected (even with others), treat as 'all'
            if (selectedValues.includes('all')) {
                return ['all'];
            }
             // If 'marked_y' is selected (even with others), prioritize it
            if (selectedValues.includes('marked_y')) {
                return ['marked_y'];
            }
            // Otherwise, return the array of selected lesson numbers
            return selectedValues.filter(val => !isNaN(parseInt(val))); // Ensure only numbers are returned
        }


        function applyFilters(shouldShuffle = true) {
            // 1. Get current filter settings
            currentFilterLevel = levelFilter.value;
            currentLessonSelection = getSelectedLessons();

            // 2. Filter the master 'allWords' list
            let filtered = allWords.filter(word => word.level === currentFilterLevel);

            // 3. Apply lesson/marking filter
            if (currentLessonSelection.includes('marked_y')) {
                filtered = filtered.filter(word => word.markedY);
            } else if (!currentLessonSelection.includes('all') && currentLessonSelection.length > 0) {
                // Filter by specific lessons if 'all' is not selected
                const numericLessons = currentLessonSelection.map(l => parseInt(l));
                filtered = filtered.filter(word => numericLessons.includes(word.lesson));
            }
            // If 'all' is selected, no further lesson filtering is needed.

            // 4. Update the currentWordList
            currentWordList = filtered;

            // 5. Shuffle if required
            if (shouldShuffle) {
                shuffleArray(currentWordList);
            }

            // 6. Reset index and update UI
            currentWordIndex = 0;
            displayWord(); // Display the first word (or empty state)
            updateProgress(); // Update progress bar and counters
            showMessage(currentWordList.length === 0 ? `No words found matching filters.` : '');
        }


        function shuffleCurrentList() {
            if (currentWordList.length > 1) {
                shuffleArray(currentWordList);
                currentWordIndex = 0;
                displayWord();
                updateProgress();
                showMessage('Words shuffled!', 2000);
            } else {
                showMessage('Not enough words to shuffle.', 2000);
            }
        }

        function displayWord() {
            const listIsEmpty = currentWordList.length === 0;

            // Reset flashcard state
            flashcard.classList.remove('is-flipped');

            // Enable/disable controls based on list content
             [prevBtn, nextBtn, markYBtn, shuffleBtn, flashcard].forEach(el => {
                el.disabled = listIsEmpty;
                // Also remove potential focus styles if disabled
                 if (listIsEmpty) {
                     el.blur();
                 }
            });
             flashcard.style.cursor = listIsEmpty ? 'default' : 'pointer';


            if (listIsEmpty) {
                // Display empty state
                characterDisplay.textContent = '—'; // Em dash for empty
                pinyinDisplay.textContent = '';
                meaningDisplay.textContent = 'No words selected';
                wordDetails.textContent = '';
                markYBtn.textContent = "Re-learn";
                markYBtn.classList.remove('marked');
                markedIndicator.style.display = 'none';
                updateProgress(); // Ensure progress shows 0/0
                return; // Stop further processing
            }

            // Ensure index is valid (useful if list shrinks)
            if (currentWordIndex < 0 || currentWordIndex >= currentWordList.length) {
                currentWordIndex = 0;
            }

            // Get the current word and display its details
            const word = currentWordList[currentWordIndex];
            characterDisplay.textContent = word.character;
            pinyinDisplay.textContent = word.pinyin;
            meaningDisplay.textContent = word.meaning;
            wordDetails.textContent = `${word.level} · Lesson ${word.lesson}`;

            // Update marking button and indicator
            const isMarked = word.markedY;
            markYBtn.textContent = isMarked ? "Learnt" : "Re-learn";
            markYBtn.classList.toggle('marked', isMarked);
            markedIndicator.style.display = isMarked ? 'block' : 'none';
        }

        function updateProgress() {
            const total = currentWordList.length;
            const currentNum = total === 0 ? 0 : currentWordIndex + 1;

            wordCounter.textContent = `Word ${currentNum} of ${total}`;

            const percent = total === 0 ? 0 : Math.round((currentNum / total) * 100);
            progressBar.style.width = `${percent}%`;
            progressPercent.textContent = `${percent}%`;
        }

        let messageTimeout; // Store timeout ID to clear previous messages
        function showMessage(msg, duration = 3000) {
            clearTimeout(messageTimeout); // Clear any existing message timeout
            messageArea.textContent = msg;
            if (msg && duration > 0) {
                messageTimeout = setTimeout(() => {
                    messageArea.textContent = ''; // Clear message after duration
                }, duration);
            }
        }

        // --- Event Handlers ---
        flashcard.addEventListener('click', () => {
            if (currentWordList.length === 0 || flashcard.disabled) return; // Don't flip if empty or disabled
            flashcard.classList.toggle('is-flipped');
        });

        markYBtn.addEventListener('click', () => {
            if (currentWordList.length === 0) return;

            const word = currentWordList[currentWordIndex];
            word.markedY = !word.markedY; // Toggle status on the current list item

            // Update the global markedWords dictionary for saving
            markedWords[word.character] = word.markedY;

            // Also update the status in the master 'allWords' list
            const indexInAllWords = allWords.findIndex(w =>
                w.character === word.character && w.level === word.level // Match more specifically if needed
            );
            if (indexInAllWords !== -1) {
                allWords[indexInAllWords].markedY = word.markedY;
            }

            saveMarkedWords(); // Save the change to local storage
            displayWord(); // Update the card UI immediately

            // Special case: If viewing "Only Re-learn" and the current word is unmarked,
            // the list needs to be refiltered immediately.
            if (currentLessonSelection.includes('marked_y') && !word.markedY) {
                 showMessage(`'${word.character}' unmarked. Updating list...`, 1500);
                 // Apply filters again, but *don't* reshuffle, keep position if possible (though it will likely remove the item)
                 // A slight delay can make the transition smoother
                 setTimeout(() => applyFilters(false), 300);
            }
        });


        nextBtn.addEventListener('click', () => {
            if (currentWordList.length === 0) return;
            currentWordIndex = (currentWordIndex + 1) % currentWordList.length;
            displayWord();
            updateProgress();
        });

        prevBtn.addEventListener('click', () => {
            if (currentWordList.length === 0) return;
            currentWordIndex = (currentWordIndex - 1 + currentWordList.length) % currentWordList.length;
            displayWord();
            updateProgress();
        });

        shuffleBtn.addEventListener('click', shuffleCurrentList);

        levelFilter.addEventListener('change', () => {
            currentFilterLevel = levelFilter.value; // Update state immediately
            populateLessonFilter(); // Update lesson options for the new level
            applyFilters(); // Apply filters (will shuffle by default)
        });

        lessonFilter.addEventListener('change', () => {
            // No need to repopulate lessons, just apply the new lesson filter
            applyFilters(); // Apply filters (will shuffle by default)
        });

        resetBtn.addEventListener('click', () => {
            resetLessonFilterSelection(); // Set dropdown to 'All Lessons'
            applyFilters(); // Re-apply filters with default lesson selection (shuffles)
            showMessage('Filters reset to default & list shuffled', 2500);
        });

        // --- Touch swipe support ---
        let touchStartX = 0;
        let touchEndX = 0;
        const swipeThreshold = 50; // Minimum pixels to register swipe

        flashcard.addEventListener('touchstart', e => {
             if (currentWordList.length === 0) return;
            touchStartX = e.changedTouches[0].screenX;
        }, { passive: true }); // Use passive for potentially smoother scrolling

        flashcard.addEventListener('touchend', e => {
             if (currentWordList.length === 0) return;
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;

            if (deltaX < -swipeThreshold) {
                // Swipe left (->): Next card
                nextBtn.click();
            } else if (deltaX > swipeThreshold) {
                // Swipe right (<-): Previous card
                prevBtn.click();
            }
            // Reset coordinates for next potential swipe
            touchStartX = 0;
            touchEndX = 0;
        }

        // --- Keyboard Navigation ---
        document.addEventListener('keydown', e => {
             // Don't intercept keyboard events if user is interacting with select dropdowns
            if (document.activeElement.tagName === 'SELECT') {
                return;
            }

            if (currentWordList.length === 0 && !['r','R'].includes(e.key)) { // Allow Reset even when empty
                return; // Ignore navigation keys if no words are loaded
            }

            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault(); // Prevent browser back navigation
                    prevBtn.click();
                    break;
                case 'ArrowRight':
                    e.preventDefault(); // Prevent default arrow key behavior
                    nextBtn.click();
                    break;
                case ' ': // Space bar
                    e.preventDefault(); // Prevent page scroll
                    flashcard.click(); // Toggle card flip
                    break;
                case 'y':
                case 'Y':
                    markYBtn.click(); // Toggle mark
                    break;
                case 's':
                case 'S':
                    shuffleBtn.click(); // Shuffle
                    break;
                case 'r': // Add 'r' for reset?
                case 'R':
                     resetBtn.click();
                     break;

            }
        });

        // Update init function to set up search functionality
        async function init() {
            console.log("Initializing Flashcard App...");
            loadMarkedWords();
            
            const success = await fetchWordsFromSheet();
            
            if (success) {
                levelFilter.value = currentFilterLevel;
                populateLessonFilter();
                applyFilters();
                showMessage('Welcome! Words loaded from Google Sheet.', 5000);
                
                // Enable controls
                [prevBtn, nextBtn, markYBtn, shuffleBtn, flashcard, levelFilter, lessonFilter, resetBtn, 
                 searchToggle, searchInput, searchButton].forEach(el => el.disabled = false);
                flashcard.style.cursor = 'pointer';
            } else {
                // Disable search if data loading failed
                searchToggle.disabled = true;
            }
        }
        
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
